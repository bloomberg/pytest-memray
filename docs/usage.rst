Usage
=====

Installation
~~~~~~~~~~~~

This plugin can be installed using pip:


.. code-block:: shell

   pip install pytest-memray


``pytest-memray`` is a pytest plugin. It is enabled when you pass ``--memray`` to
pytest:

.. code-block:: shell

   pytest tests/ --memray

Allocation tracking
~~~~~~~~~~~~~~~~~~~

By default, the plugin will track allocations at the high watermark in all tests. This information is
reported after tests run ends:

.. command-output:: env COLUMNS=92 pytest --memray demo
   :returncode: 1

Markers
~~~~~~~

This plugin provides markers that can be used to enforce additional checks and
validations on tests when this plugin is enabled.

.. important:: These markers do nothing when the plugin is not enabled.


``limit_memory``
----------------

.. py:function:: limit_memory(memory_limit: str)
    Fail the execution of the test if the test allocates more memory than allowed

When this marker is applied to a test, it will cause the test to fail if the execution
of the test allocates more memory than allowed. It takes a single argument with a
string indicating the maximum memory that the test can allocate.

The format for the string is ``<NUMBER> ([KMGTP]B|B)``. The marker will raise
``ValueError`` if the string format cannot be parsed correctly.

.. warning::

    As the Python interpreter has its own
    `object allocator <https://docs.python.org/3/c-api/memory.html>`__ is possible
    that memory is not immediately released to the system when objects are deleted, so
    tests using this marker may need to give some room to account for this.

Example of usage:

.. code-block:: python

    @pytest.mark.limit_memory("24 MB")
    def test_foobar():
        pass  # do some stuff that allocates memory


``limit_leaks``
---------------

 .. py:function:: limit_leaks(location_limit: str, filtering_fn: Callable[Iterable[Tuple[str, str, int]], bool])
       Fail the execution of the test if any location in the test leaks more memory than allowed.

 .. important::
       To detect leaks, Memray needs to intercept calls to the Python allocators and use native
       traces. This is adds significant overhead, and will slow your test down.

When this marker is applied to a test, it will cause the test to fail if any allocation location in
the execution of the test leaks more memory than allowed. It takes a single positional argument with a
string indicating the maximum memory **per allocation location** that the test is allowed to leak.

Leaks are defined as memory that is allocated **in the marked test** that is not freed before leaving the test body.

.. important::
    It's recommended to run your API or code in a loop when utilizing this plugin. This practice helps in distinguishing
    genuine leaks from the "noise" generated by internal caches and other incidental allocations.

The format for the string is ``<NUMBER> ([KMGTP]B|B)``. The marker will raise
``ValueError`` if the string format cannot be parsed correctly.

The marker also takes an optional keyword-only argument ``filtering_fn``. This argument represents a filtering
function that will be called with the traceback for every location that allocates memory that cumulatively is
bigger than the provided limit. The function must return *True* if the allocation must be taken into account
and *False* otherwise. This function can be used to discard some false positives detected by the marker.

.. tip::

   You can pass the ``--memray-bin-path`` argument to ``pytest`` to specify
   a directory where Memray will store the binary files with the results. You
   can then use the ``memray`` CLI to further investigate the allocations and the
   leaks using any Memray reporters you'd like. Check `the memray docs
   <https://bloomberg.github.io/memray/getting_started.html>`_ for more
   information.

Example of usage:

.. code-block:: python

    @pytest.mark.limit_leaks("1 MB")
    def test_foobar():
        # Run the function to test in a loop to ensure
        # we can differentiate leaks from memory allocated
        # in internal caches
        for _ in range(100):
            do_some_stuff()

.. warning::
   Is **very** challenging to write tests that do not "leak" memory in some way.
   interpreter caches but there are some that cannot be correctly detected so
   you may need to allow some small amount of leaked memory per location or use the
   ``filtering_fn`` argument to filter out false positive leak reports caused by
   objects that the interpreter plans to reuse later. These caches are
   implementation details of the interpreter, so the amount of memory
   allocated, the location of the allocation, and the allocator that was used
   can all change from one Python version to another.
